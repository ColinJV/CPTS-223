1. Machine processing power will affect execution time dependent on the task. For this task, most of the operations are memory access, so a machine with faster memory should perform better.
2. The performance advantages of a std::list and a std::vector vary based on the task being performed. In general a std::list with an iterator to a position can perform insertions and deletions at the position of that iterator in constant time which makes it ideal for this program since throughout the entirety of the test simulation between N and N^2 deletions are performed at random locations in the list (since M is random between 1 and N as N goes from 1 to 1025). A std::vector is ill suited for this task because deletions from the middle requires shifting elements, and the implementation of the problem called for using an iterator for a functionally identical implementation to the std::list, which negated any advantage a std::vector might have had with random access. The std::list should perform better here theoretically since we frequently delete from the middle of the list, but this is not borne out when looking at the average simulation time on my PC.
3. Both M and N impact runtime equally for a std::list and N impacts runtime more for a std::vector. As N increases, the number of deletions that must be performed also increases. As N increases, the potential ceiling of M increases. As M increases, the number of traversals that must be performed prior to removing an element from the list increases. Since a std::vector must shift elements when deleting from the middle, it performs deletions in the middle in O(n) time instead of constant time and its performance is more influenced by N.